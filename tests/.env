TESTFILE_PREFIX="test"
SKIPPING_TEST_MESSAGE="Skipping test..."
PROGRAM_NAME=$(basename "$0")
# regex strips any str prefix from the program name (e.g. if TESTFILE_PREFIX = test; then testshellfuncs_foo => shellfuncs_foo))
SHELLFUNC_NAME="$(echo "$PROGRAM_NAME" | grep --only-matching --perl-regexp "(?<=.{${#TESTFILE_PREFIX}})(.+)")"
SHELLFUNCS_DOTFILE_PATH="${HOME}/.profile"
. "$SHELLFUNCS_DOTFILE_PATH" > /dev/null 2>&1

#######################################
# Loads each 'shellfuncs' script into from 
# SHELLFUNCS_OTHER_SCRIPTS_PATH the current shell session.
# Globals:
#   SHELLFUNCS_REPO_PATH
#   SHELLFUNCS_OTHER_SCRIPTS_PATH
#   SUCCESS
#   ERROR
# Outputs:
#   ERROR: If shellfuncs repo could not be found
#######################################
load_other_shellfuncs () {
    if [ -d "$SHELLFUNCS_REPO_PATH" ]; then
        # shellcheck source=/dev/null
        for script_name in "${SHELLFUNCS_OTHER_SCRIPTS_PATH}/"*; do
            . "$script_name"
        done
        # is the current shell interpreting this bash?
        # NOTE: default will be considered some 'sh', assuming backslashes are already interpreted
        if [ -n "${BASH_VERSION:-}" ]; then
            echo -e "$SUCCESS Loaded 'shellfuncs' repo OTHER scripts" > /dev/null 2>&1
        else
            echo "$SUCCESS Loaded 'shellfuncs' repo OTHER scripts" > /dev/null 2>&1
        fi
    else
        if [ -n "${BASH_VERSION:-}" ]; then
            echo -e "$ERROR 'shellfuncs' repo could not be found, failed to load OTHER scripts"
        else
            echo "$ERROR 'shellfuncs' repo could not be found, failed to load OTHER scripts"
        fi
        return 1
    fi
    return 0
}

load_other_shellfuncs
